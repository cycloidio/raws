package raws

import (
	"context"
	"io"

	"github.com/aws/aws-sdk-go/service/cloudfront"
	"github.com/aws/aws-sdk-go/service/configservice"
	"github.com/aws/aws-sdk-go/service/ec2"
	"github.com/aws/aws-sdk-go/service/elasticache"
	"github.com/aws/aws-sdk-go/service/elb"
	"github.com/aws/aws-sdk-go/service/elbv2"
	"github.com/aws/aws-sdk-go/service/iam"
	"github.com/aws/aws-sdk-go/service/rds"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/aws/aws-sdk-go/service/s3/s3manager"
)

// Code generated by github.com/cycloidio/raws/cmd; DO NOT EDIT

// AWSReader is the interface defining all methods that need to be implemented
//
// The next behavior commented in the below paragraph, applies to every method
// which clearly match what's explained, for the sake of not repeating the same,
// over and over.
// The most of the methods defined by this interface, return their results in a
// map. Those maps, have as keys, the AWS region which have been requested and
// the values are the items returned by AWS for such region.
// Because the methods may make calls to different regions, in case that there
// is an error on a region, the returned map won't have any entry for such
// region and such errors will be reported by the returned error, nonetheless
// the items, got from the successful requests to other regions, will be
// returned, with the meaning that the methods will return partial results, in
// case of errors.
// For avoiding by the callers the problem of if the returned map may be nil,
// the function will always return a map instance, which will be of length 0
// in case that there is not any successful request.
type AWSReader interface {
	// GetAccountID returns the current ID for the account used
	GetAccountID() string

	// GetRegions returns the currently used regions for the Connector
	GetRegions() []string

	// GetInstances returns all EC2 instances based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetInstances(ctx context.Context, input *ec2.DescribeInstancesInput) (map[string]ec2.DescribeInstancesOutput, error)

	// GetVpcs returns all EC2 VPCs based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetVpcs(ctx context.Context, input *ec2.DescribeVpcsInput) (map[string]ec2.DescribeVpcsOutput, error)

	// GetImages returns all EC2 AMI based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetImages(ctx context.Context, input *ec2.DescribeImagesInput) (map[string]ec2.DescribeImagesOutput, error)

	// GetOwnImages returns all EC2 AMI belonging to the Account ID based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetOwnImages(ctx context.Context, input *ec2.DescribeImagesInput) (map[string]ec2.DescribeImagesOutput, error)

	// GetSecurityGroups returns all EC2 security groups based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetSecurityGroups(ctx context.Context, input *ec2.DescribeSecurityGroupsInput) (map[string]ec2.DescribeSecurityGroupsOutput, error)

	// GetSubnets returns all EC2 subnets based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetSubnets(ctx context.Context, input *ec2.DescribeSubnetsInput) (map[string]ec2.DescribeSubnetsOutput, error)

	// GetVolumes returns all EC2 volumes based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetVolumes(ctx context.Context, input *ec2.DescribeVolumesInput) (map[string]ec2.DescribeVolumesOutput, error)

	// GetSnapshots returns all snapshots based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetSnapshots(ctx context.Context, input *ec2.DescribeSnapshotsInput) (map[string]ec2.DescribeSnapshotsOutput, error)

	// GetOwnSnapshots returns all snapshots belonging to the Account ID based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetOwnSnapshots(ctx context.Context, input *ec2.DescribeSnapshotsInput) (map[string]ec2.DescribeSnapshotsOutput, error)

	// GetElastiCacheClusters returns all Elasticache clusters based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetElastiCacheClusters(ctx context.Context, input *elasticache.DescribeCacheClustersInput) (map[string]elasticache.DescribeCacheClustersOutput, error)

	// GetElastiCacheTags returns a list of tags of Elasticache resources based on its ARN.
	// Returned values are commented in the interface doc comment block.
	GetElastiCacheTags(ctx context.Context, input *elasticache.ListTagsForResourceInput) (map[string]elasticache.TagListMessage, error)

	// GetLoadBalancers returns a list of ELB (v1) based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancers(ctx context.Context, input *elb.DescribeLoadBalancersInput) (map[string]elb.DescribeLoadBalancersOutput, error)

	// GetLoadBalancersTags returns a list of Tags based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersTags(ctx context.Context, input *elb.DescribeTagsInput) (map[string]elb.DescribeTagsOutput, error)

	// GetLoadBalancersV2 returns a list of ELB (v2) - also known as ALB - based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersV2(ctx context.Context, input *elbv2.DescribeLoadBalancersInput) (map[string]elbv2.DescribeLoadBalancersOutput, error)

	// GetLoadBalancersV2Tags returns a list of Tags based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersV2Tags(ctx context.Context, input *elbv2.DescribeTagsInput) (map[string]elbv2.DescribeTagsOutput, error)

	// GetDBInstances returns all DB instances based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetDBInstances(ctx context.Context, input *rds.DescribeDBInstancesInput) (map[string]rds.DescribeDBInstancesOutput, error)

	// GetDBInstancesTags returns a list of tags from an ARN, extra filters for tags can also be provided.
	// Returned values are commented in the interface doc comment block.
	GetDBInstancesTags(ctx context.Context, input *rds.ListTagsForResourceInput) (map[string]rds.ListTagsForResourceOutput, error)

	// ListBuckets returns all S3 buckets based on the input given.
	// Returned values are commented in the interface doc comment block.
	ListBuckets(ctx context.Context, input *s3.ListBucketsInput) (map[string]s3.ListBucketsOutput, error)

	// GetBucketTags returns tags associated with S3 buckets based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetBucketTags(ctx context.Context, input *s3.GetBucketTaggingInput) (map[string]s3.GetBucketTaggingOutput, error)

	// ListObjects returns a list of all S3 objects in a bucket based on the input given.
	// Returned values are commented in the interface doc comment block.
	ListObjects(ctx context.Context, input *s3.ListObjectsInput) (map[string]s3.ListObjectsOutput, error)

	// GetObjectsTags returns tags associated with S3 objects based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetObjectsTags(ctx context.Context, input *s3.GetObjectTaggingInput) (map[string]s3.GetObjectTaggingOutput, error)

	// GetRecordedResourceCounts returns counts of the AWS resources which have
	// been recorded by AWS Config.
	// See https://docs.aws.amazon.com/config/latest/APIReference/API_GetDiscoveredResourceCounts.html
	// for more information about what to enable in your AWS account, the list of
	// supported resources, etc.
	GetRecordedResourceCounts(ctx context.Context, input *configservice.GetDiscoveredResourceCountsInput) (map[string]configservice.GetDiscoveredResourceCountsOutput, error)

	// DownloadObject downloads an object in a bucket based on the input given
	DownloadObject(ctx context.Context, w io.WriterAt, input *s3.GetObjectInput, options ...func(*s3manager.Downloader)) (int64, error)

	// GetCloudFrontDistributions returns all the CloudFront Distributions on the given input
	// Returned values are commented in the interface doc comment block.
	GetCloudFrontDistributions(ctx context.Context, input *cloudfront.ListDistributionsInput) (map[string]cloudfront.ListDistributionsOutput, error)

	// GetCloudFrontPublicKeys returns all the CloudFront Public Keys on the given input
	// Returned values are commented in the interface doc comment block.
	GetCloudFrontPublicKeys(ctx context.Context, input *cloudfront.ListPublicKeysInput) (map[string]cloudfront.ListPublicKeysOutput, error)

	// GetCloudFrontOriginAccessIdentities returns all the CloudFront Origin Access Identities on the given input
	// Returned values are commented in the interface doc comment block.
	GetCloudFrontOriginAccessIdentities(ctx context.Context, input *cloudfront.ListCloudFrontOriginAccessIdentitiesInput) (map[string]cloudfront.ListCloudFrontOriginAccessIdentitiesOutput, error)

	// GetAccessKeys returns all the IAM AccessKeys on the given input
	// Returned values are commented in the interface doc comment block.
	GetAccessKeys(ctx context.Context, input *iam.ListAccessKeysInput) (map[string]iam.ListAccessKeysOutput, error)

	// GetAccountAliases returns all the IAM AccountAliases on the given input
	// Returned values are commented in the interface doc comment block.
	GetAccountAliases(ctx context.Context, input *iam.ListAccountAliasesInput) (map[string]iam.ListAccountAliasesOutput, error)

	// GetAccountPasswordPolicy returns the IAM AccountPasswordPolicy on the given input
	// Returned values are commented in the interface doc comment block.
	GetAccountPasswordPolicy(ctx context.Context, input *iam.GetAccountPasswordPolicyInput) (map[string]iam.GetAccountPasswordPolicyOutput, error)

	// GetGroups returns the IAM Groups on the given input
	// Returned values are commented in the interface doc comment block.
	GetGroups(ctx context.Context, input *iam.ListGroupsInput) (map[string]iam.ListGroupsOutput, error)

	// GetGroupPolicies returns the IAM GroupPolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetGroupPolicies(ctx context.Context, input *iam.ListGroupPoliciesInput) (map[string]iam.ListGroupPoliciesOutput, error)

	// GetAttachedGroupPolicies returns the IAM AttachedGroupPolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetAttachedGroupPolicies(ctx context.Context, input *iam.ListAttachedGroupPoliciesInput) (map[string]iam.ListAttachedGroupPoliciesOutput, error)

	// GetIstanceProfiles returns the IAM InstanceProfiles on the given input
	// Returned values are commented in the interface doc comment block.
	GetInstanceProfiles(ctx context.Context, input *iam.ListInstanceProfilesInput) (map[string]iam.ListInstanceProfilesOutput, error)

	// GetOpenIDConnectProviders returns the IAM OpenIDConnectProviders on the given input
	// Returned values are commented in the interface doc comment block.
	GetOpenIDConnectProviders(ctx context.Context, input *iam.ListOpenIDConnectProvidersInput) (map[string]iam.ListOpenIDConnectProvidersOutput, error)

	// GetPolicies returns the IAM Policies on the given input
	// Returned values are commented in the interface doc comment block.
	GetPolicies(ctx context.Context, input *iam.ListPoliciesInput) (map[string]iam.ListPoliciesOutput, error)

	// GetRoles returns the IAM Roles on the given input
	// Returned values are commented in the interface doc comment block.
	GetRoles(ctx context.Context, input *iam.ListRolesInput) (map[string]iam.ListRolesOutput, error)

	// GetRolePolicies returns the IAM RolePolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetRolePolicies(ctx context.Context, input *iam.ListRolePoliciesInput) (map[string]iam.ListRolePoliciesOutput, error)

	// GetAttachedRolePolicies returns the IAM AttachedRolePolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetAttachedRolePolicies(ctx context.Context, input *iam.ListAttachedRolePoliciesInput) (map[string]iam.ListAttachedRolePoliciesOutput, error)

	// GetSAMLProviders returns the IAM SAMLProviders on the given input
	// Returned values are commented in the interface doc comment block.
	GetSAMLProviders(ctx context.Context, input *iam.ListSAMLProvidersInput) (map[string]iam.ListSAMLProvidersOutput, error)

	// GetServerCertificates returns the IAM ServerCertificates on the given input
	// Returned values are commented in the interface doc comment block.
	GetServerCertificates(ctx context.Context, input *iam.ListServerCertificatesInput) (map[string]iam.ListServerCertificatesOutput, error)

	// GetUsers returns the IAM Users on the given input
	// Returned values are commented in the interface doc comment block.
	GetUsers(ctx context.Context, input *iam.ListUsersInput) (map[string]iam.ListUsersOutput, error)

	// GetUserPolicies returns the IAM UserPolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetUserPolicies(ctx context.Context, input *iam.ListUserPoliciesInput) (map[string]iam.ListUserPoliciesOutput, error)

	// GetAttachedUserPolicies returns the IAM AttachedUserPolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetAttachedUserPolicies(ctx context.Context, input *iam.ListAttachedUserPoliciesInput) (map[string]iam.ListAttachedUserPoliciesOutput, error)

	// GetSSHPublicKey returns the IAM SSHPublicKey on the given input
	// Returned values are commented in the interface doc comment block.
	GetSSHPublicKey(ctx context.Context, input *iam.GetSSHPublicKeyInput) (map[string]iam.GetSSHPublicKeyOutput, error)
}

func (c *connector) GetInstances(ctx context.Context, input *ec2.DescribeInstancesInput) (map[string]ec2.DescribeInstancesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]ec2.DescribeInstancesOutput{}

	for _, svc := range c.svcs {
		if svc.ec2 == nil {
			svc.ec2 = ec2.New(svc.session)
		}

		opt, err := svc.ec2.DescribeInstancesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, ec2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetVpcs(ctx context.Context, input *ec2.DescribeVpcsInput) (map[string]ec2.DescribeVpcsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]ec2.DescribeVpcsOutput{}

	for _, svc := range c.svcs {
		if svc.ec2 == nil {
			svc.ec2 = ec2.New(svc.session)
		}

		opt, err := svc.ec2.DescribeVpcsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, ec2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetImages(ctx context.Context, input *ec2.DescribeImagesInput) (map[string]ec2.DescribeImagesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]ec2.DescribeImagesOutput{}

	for _, svc := range c.svcs {
		if svc.ec2 == nil {
			svc.ec2 = ec2.New(svc.session)
		}

		opt, err := svc.ec2.DescribeImagesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, ec2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetOwnImages(ctx context.Context, input *ec2.DescribeImagesInput) (map[string]ec2.DescribeImagesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]ec2.DescribeImagesOutput{}

	if input == nil {
		input = &ec2.DescribeImagesInput{}
	}
	input.Owners = append(input.Owners, c.accountID)

	for _, svc := range c.svcs {
		if svc.ec2 == nil {
			svc.ec2 = ec2.New(svc.session)
		}

		opt, err := svc.ec2.DescribeImagesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, ec2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetSecurityGroups(ctx context.Context, input *ec2.DescribeSecurityGroupsInput) (map[string]ec2.DescribeSecurityGroupsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]ec2.DescribeSecurityGroupsOutput{}

	for _, svc := range c.svcs {
		if svc.ec2 == nil {
			svc.ec2 = ec2.New(svc.session)
		}

		opt, err := svc.ec2.DescribeSecurityGroupsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, ec2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetSubnets(ctx context.Context, input *ec2.DescribeSubnetsInput) (map[string]ec2.DescribeSubnetsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]ec2.DescribeSubnetsOutput{}

	for _, svc := range c.svcs {
		if svc.ec2 == nil {
			svc.ec2 = ec2.New(svc.session)
		}

		opt, err := svc.ec2.DescribeSubnetsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, ec2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetVolumes(ctx context.Context, input *ec2.DescribeVolumesInput) (map[string]ec2.DescribeVolumesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]ec2.DescribeVolumesOutput{}

	for _, svc := range c.svcs {
		if svc.ec2 == nil {
			svc.ec2 = ec2.New(svc.session)
		}

		opt, err := svc.ec2.DescribeVolumesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, ec2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetSnapshots(ctx context.Context, input *ec2.DescribeSnapshotsInput) (map[string]ec2.DescribeSnapshotsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]ec2.DescribeSnapshotsOutput{}

	for _, svc := range c.svcs {
		if svc.ec2 == nil {
			svc.ec2 = ec2.New(svc.session)
		}

		opt, err := svc.ec2.DescribeSnapshotsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, ec2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetOwnSnapshots(ctx context.Context, input *ec2.DescribeSnapshotsInput) (map[string]ec2.DescribeSnapshotsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]ec2.DescribeSnapshotsOutput{}

	if input == nil {
		input = &ec2.DescribeSnapshotsInput{}
	}
	input.OwnerIds = append(input.OwnerIds, c.accountID)

	for _, svc := range c.svcs {
		if svc.ec2 == nil {
			svc.ec2 = ec2.New(svc.session)
		}

		opt, err := svc.ec2.DescribeSnapshotsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, ec2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetElastiCacheClusters(ctx context.Context, input *elasticache.DescribeCacheClustersInput) (map[string]elasticache.DescribeCacheClustersOutput, error) {
	var errs Errors
	var regionsOpts = map[string]elasticache.DescribeCacheClustersOutput{}

	for _, svc := range c.svcs {
		if svc.elasticache == nil {
			svc.elasticache = elasticache.New(svc.session)
		}

		opt, err := svc.elasticache.DescribeCacheClustersWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, elasticache.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetElastiCacheTags(ctx context.Context, input *elasticache.ListTagsForResourceInput) (map[string]elasticache.TagListMessage, error) {
	var errs Errors
	var regionsOpts = map[string]elasticache.TagListMessage{}

	for _, svc := range c.svcs {
		if svc.elasticache == nil {
			svc.elasticache = elasticache.New(svc.session)
		}

		opt, err := svc.elasticache.ListTagsForResourceWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, elasticache.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetLoadBalancers(ctx context.Context, input *elb.DescribeLoadBalancersInput) (map[string]elb.DescribeLoadBalancersOutput, error) {
	var errs Errors
	var regionsOpts = map[string]elb.DescribeLoadBalancersOutput{}

	for _, svc := range c.svcs {
		if svc.elb == nil {
			svc.elb = elb.New(svc.session)
		}

		opt, err := svc.elb.DescribeLoadBalancersWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, elb.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetLoadBalancersTags(ctx context.Context, input *elb.DescribeTagsInput) (map[string]elb.DescribeTagsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]elb.DescribeTagsOutput{}

	for _, svc := range c.svcs {
		if svc.elb == nil {
			svc.elb = elb.New(svc.session)
		}

		opt, err := svc.elb.DescribeTagsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, elb.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetLoadBalancersV2(ctx context.Context, input *elbv2.DescribeLoadBalancersInput) (map[string]elbv2.DescribeLoadBalancersOutput, error) {
	var errs Errors
	var regionsOpts = map[string]elbv2.DescribeLoadBalancersOutput{}

	for _, svc := range c.svcs {
		if svc.elbv2 == nil {
			svc.elbv2 = elbv2.New(svc.session)
		}

		opt, err := svc.elbv2.DescribeLoadBalancersWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, elbv2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetLoadBalancersV2Tags(ctx context.Context, input *elbv2.DescribeTagsInput) (map[string]elbv2.DescribeTagsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]elbv2.DescribeTagsOutput{}

	for _, svc := range c.svcs {
		if svc.elbv2 == nil {
			svc.elbv2 = elbv2.New(svc.session)
		}

		opt, err := svc.elbv2.DescribeTagsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, elbv2.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetDBInstances(ctx context.Context, input *rds.DescribeDBInstancesInput) (map[string]rds.DescribeDBInstancesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]rds.DescribeDBInstancesOutput{}

	for _, svc := range c.svcs {
		if svc.rds == nil {
			svc.rds = rds.New(svc.session)
		}

		opt, err := svc.rds.DescribeDBInstancesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, rds.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetDBInstancesTags(ctx context.Context, input *rds.ListTagsForResourceInput) (map[string]rds.ListTagsForResourceOutput, error) {
	var errs Errors
	var regionsOpts = map[string]rds.ListTagsForResourceOutput{}

	for _, svc := range c.svcs {
		if svc.rds == nil {
			svc.rds = rds.New(svc.session)
		}

		opt, err := svc.rds.ListTagsForResourceWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, rds.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) ListBuckets(ctx context.Context, input *s3.ListBucketsInput) (map[string]s3.ListBucketsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]s3.ListBucketsOutput{}

	for _, svc := range c.svcs {
		if svc.s3 == nil {
			svc.s3 = s3.New(svc.session)
		}

		opt, err := svc.s3.ListBucketsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, s3.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetBucketTags(ctx context.Context, input *s3.GetBucketTaggingInput) (map[string]s3.GetBucketTaggingOutput, error) {
	var errs Errors
	var regionsOpts = map[string]s3.GetBucketTaggingOutput{}

	for _, svc := range c.svcs {
		if svc.s3 == nil {
			svc.s3 = s3.New(svc.session)
		}

		opt, err := svc.s3.GetBucketTaggingWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, s3.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) ListObjects(ctx context.Context, input *s3.ListObjectsInput) (map[string]s3.ListObjectsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]s3.ListObjectsOutput{}

	for _, svc := range c.svcs {
		if svc.s3 == nil {
			svc.s3 = s3.New(svc.session)
		}

		opt, err := svc.s3.ListObjectsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, s3.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetObjectsTags(ctx context.Context, input *s3.GetObjectTaggingInput) (map[string]s3.GetObjectTaggingOutput, error) {
	var errs Errors
	var regionsOpts = map[string]s3.GetObjectTaggingOutput{}

	for _, svc := range c.svcs {
		if svc.s3 == nil {
			svc.s3 = s3.New(svc.session)
		}

		opt, err := svc.s3.GetObjectTaggingWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, s3.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetRecordedResourceCounts(ctx context.Context, input *configservice.GetDiscoveredResourceCountsInput) (map[string]configservice.GetDiscoveredResourceCountsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]configservice.GetDiscoveredResourceCountsOutput{}

	for _, svc := range c.svcs {
		if svc.configservice == nil {
			svc.configservice = configservice.New(svc.session)
		}

		opt, err := svc.configservice.GetDiscoveredResourceCountsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, configservice.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetCloudFrontDistributions(ctx context.Context, input *cloudfront.ListDistributionsInput) (map[string]cloudfront.ListDistributionsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]cloudfront.ListDistributionsOutput{}

	for _, svc := range c.svcs {
		if svc.cloudfront == nil {
			svc.cloudfront = cloudfront.New(svc.session)
		}

		opt, err := svc.cloudfront.ListDistributionsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, cloudfront.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetCloudFrontPublicKeys(ctx context.Context, input *cloudfront.ListPublicKeysInput) (map[string]cloudfront.ListPublicKeysOutput, error) {
	var errs Errors
	var regionsOpts = map[string]cloudfront.ListPublicKeysOutput{}

	for _, svc := range c.svcs {
		if svc.cloudfront == nil {
			svc.cloudfront = cloudfront.New(svc.session)
		}

		opt, err := svc.cloudfront.ListPublicKeysWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, cloudfront.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetCloudFrontOriginAccessIdentities(ctx context.Context, input *cloudfront.ListCloudFrontOriginAccessIdentitiesInput) (map[string]cloudfront.ListCloudFrontOriginAccessIdentitiesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]cloudfront.ListCloudFrontOriginAccessIdentitiesOutput{}

	for _, svc := range c.svcs {
		if svc.cloudfront == nil {
			svc.cloudfront = cloudfront.New(svc.session)
		}

		opt, err := svc.cloudfront.ListCloudFrontOriginAccessIdentitiesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, cloudfront.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetAccessKeys(ctx context.Context, input *iam.ListAccessKeysInput) (map[string]iam.ListAccessKeysOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListAccessKeysOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListAccessKeysWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetAccountAliases(ctx context.Context, input *iam.ListAccountAliasesInput) (map[string]iam.ListAccountAliasesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListAccountAliasesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListAccountAliasesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetAccountPasswordPolicy(ctx context.Context, input *iam.GetAccountPasswordPolicyInput) (map[string]iam.GetAccountPasswordPolicyOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.GetAccountPasswordPolicyOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.GetAccountPasswordPolicyWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetGroups(ctx context.Context, input *iam.ListGroupsInput) (map[string]iam.ListGroupsOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListGroupsOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListGroupsWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetGroupPolicies(ctx context.Context, input *iam.ListGroupPoliciesInput) (map[string]iam.ListGroupPoliciesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListGroupPoliciesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListGroupPoliciesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetAttachedGroupPolicies(ctx context.Context, input *iam.ListAttachedGroupPoliciesInput) (map[string]iam.ListAttachedGroupPoliciesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListAttachedGroupPoliciesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListAttachedGroupPoliciesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetInstanceProfiles(ctx context.Context, input *iam.ListInstanceProfilesInput) (map[string]iam.ListInstanceProfilesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListInstanceProfilesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListInstanceProfilesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetOpenIDConnectProviders(ctx context.Context, input *iam.ListOpenIDConnectProvidersInput) (map[string]iam.ListOpenIDConnectProvidersOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListOpenIDConnectProvidersOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListOpenIDConnectProvidersWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetPolicies(ctx context.Context, input *iam.ListPoliciesInput) (map[string]iam.ListPoliciesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListPoliciesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListPoliciesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetRoles(ctx context.Context, input *iam.ListRolesInput) (map[string]iam.ListRolesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListRolesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListRolesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetRolePolicies(ctx context.Context, input *iam.ListRolePoliciesInput) (map[string]iam.ListRolePoliciesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListRolePoliciesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListRolePoliciesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetAttachedRolePolicies(ctx context.Context, input *iam.ListAttachedRolePoliciesInput) (map[string]iam.ListAttachedRolePoliciesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListAttachedRolePoliciesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListAttachedRolePoliciesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetSAMLProviders(ctx context.Context, input *iam.ListSAMLProvidersInput) (map[string]iam.ListSAMLProvidersOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListSAMLProvidersOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListSAMLProvidersWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetServerCertificates(ctx context.Context, input *iam.ListServerCertificatesInput) (map[string]iam.ListServerCertificatesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListServerCertificatesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListServerCertificatesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetUsers(ctx context.Context, input *iam.ListUsersInput) (map[string]iam.ListUsersOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListUsersOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListUsersWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetUserPolicies(ctx context.Context, input *iam.ListUserPoliciesInput) (map[string]iam.ListUserPoliciesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListUserPoliciesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListUserPoliciesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetAttachedUserPolicies(ctx context.Context, input *iam.ListAttachedUserPoliciesInput) (map[string]iam.ListAttachedUserPoliciesOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.ListAttachedUserPoliciesOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.ListAttachedUserPoliciesWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}

func (c *connector) GetSSHPublicKey(ctx context.Context, input *iam.GetSSHPublicKeyInput) (map[string]iam.GetSSHPublicKeyOutput, error) {
	var errs Errors
	var regionsOpts = map[string]iam.GetSSHPublicKeyOutput{}

	for _, svc := range c.svcs {
		if svc.iam == nil {
			svc.iam = iam.New(svc.session)
		}

		opt, err := svc.iam.GetSSHPublicKeyWithContext(ctx, input)
		if err != nil {
			errs = append(errs, NewError(svc.region, iam.ServiceName, err))
		} else {
			regionsOpts[svc.region] = *opt
		}
	}

	if errs != nil {
		return regionsOpts, errs
	}

	return regionsOpts, nil
}
