package main

import (
	"fmt"
	"html/template"
	"io"

	"github.com/pkg/errors"
)

const (
	// packageTmpl it's the package definition
	packageTmpl = `
	package raws

	// Code generated by github.com/cycloidio/raws/cmd; DO NOT EDIT
	`

	// arTmpl it's the AWSReader interface template definition
	arTmpl = `
	// AWSReader is the interface defining all methods that need to be implemented
	//
	// The next behavior commented in the below paragraph, applies to every method
	// which clearly match what's explained, for the sake of not repeating the same,
	// over and over.
	// The most of the methods defined by this interface, return their results in a
	// map. Those maps, have as keys, the AWS region which have been requested and
	// the values are the items returned by AWS for such region.
	// Because the methods may make calls to different regions, in case that there
	// is an error on a region, the returned map won't have any entry for such
	// region and such errors will be reported by the returned error, nonetheless
	// the items, got from the successful requests to other regions, will be
	// returned, with the meaning that the methods will return partial results, in
	// case of errors.
	// For avoiding by the callers the problem of if the returned map may be nil,
	// the function will always return a map instance, which will be of length 0
	// in case that there is not any successful request.
	type AWSReader interface {
		// GetAccountID returns the current ID for the account used
		GetAccountID() string

		// GetRegions returns the currently used regions for the Connector
		GetRegions() []string

		{{ range . }}
			{{ .Documentation -}}
			{{ .Signature }}
		{{ end }}
	}
	`

	// functionTmpl it's the implementation of a function
	functionTmpl = `
		func (c *connector) {{ .Signature }} {
			var errs Errors
			var regionsOpts = map[string]{{.Output}}{}

			{{ if ne .FilterByOwner ""}}
				if input == nil {
					input = &{{.Input}}{}
				}
				input.{{.FilterByOwner}} = append(input.{{.FilterByOwner}}, c.accountID)
			{{ end }}

			for _, svc := range c.svcs {
				if svc.{{.Service}} == nil {
					svc.{{.Service}} = {{.Service}}.New(svc.session)
				}

				opt, err := svc.{{.Service}}.{{.Prefix}}{{.Entity}}WithContext(ctx, input)
				if err != nil {
					errs = append(errs, NewError(svc.region, {{.Service}}.ServiceName, err))
				} else {
					regionsOpts[svc.region] = *opt
				}
			}

			if errs != nil {
				return regionsOpts, errs
			}

			return regionsOpts, nil
		}
	`
)

var (
	fnTmpl        *template.Template
	pkgTmpl       *template.Template
	awsReaderTmpl *template.Template
)

func init() {
	var err error

	fnTmpl, err = template.New("test").Parse(functionTmpl)
	if err != nil {
		panic(err)
	}

	pkgTmpl, err = template.New("test").Parse(packageTmpl)
	if err != nil {
		panic(err)
	}

	awsReaderTmpl, err = template.New("test").Parse(arTmpl)
	if err != nil {
		panic(err)
	}
}

// Function is the definition of one of the functions
type Function struct {
	// FnName is the name of the function
	// if not defined "Get{{.Entity}i" is used
	FnName string

	// Entity is the name of the entity, like
	// CloudFrontOriginAccessIdentities, Instances etc
	Entity string

	// Some functions on AWS have the "Describe" prefix
	// or the "List" prefix, so it has to be specified
	// which one to use
	Prefix string

	// Service is the AWS service that it uses, basically the
	// pkg name, so "ec2", "cloudfront" etc
	Service string

	// Documentation is the documentation that will be added
	// to the AWSReader function definition, as it's the
	// only public part that could be seen on the godocs
	Documentation string

	// Is the Output name that it has
	FnOutput string

	// FnSignature is the signture it has to be used on the Interface
	// AWSReader and the function implementation
	FnSignature string

	// NoGenerateFn avoids generating the function implementation as
	// it's to different from the templates we use
	// If true, it should be used with 'Signature' to add it to the
	// AWSReader and have the custom implementation outside of the
	// generated code
	NoGenerateFn bool

	// FilterByOwner adds the "{{.FilterByOwner}} = AccountID" to the input filter
	// so this value has to be the correct name on the input
	FilterByOwner string
}

// Name builds a name simply using "Get{{.Entity}}"
// except if FnName is defined, in which case
// only FnName is used
func (f Function) Name() string {
	if f.FnName != "" {
		return f.FnName
	}

	prefix := "Get"
	if f.FilterByOwner != "" {
		prefix += "Own"
	}

	return fmt.Sprintf("%s%s", prefix, f.Entity)
}

// Output builds the output by "{{.Service}}.{{.Prefix}}{{.Entity}}"
// except if FnOutput is defined in which case the formula
// "{{.Service}}{{.FnOutput}}" is used
func (f Function) Output() string {
	if f.FnOutput != "" {
		return fmt.Sprintf("%s.%s", f.Service, f.FnOutput)
	}

	return fmt.Sprintf("%s.%s%sOutput", f.Service, f.Prefix, f.Entity)
}

// Input builds the input by "{{.Service}}.{{.Prefix}}{{.Entity}}"
func (f Function) Input() string {
	return fmt.Sprintf("%s.%s%sInput", f.Service, f.Prefix, f.Entity)
}

// Signature builds the signature except if FnSignature it's defined,
// in which case is used
func (f Function) Signature() string {
	if f.FnSignature != "" {
		return f.FnSignature
	}

	return fmt.Sprintf("%s (ctx context.Context, input *%s) (map[string]%s, error)", f.Name(), f.Input(), f.Output())
}

// Execute uses the fnTmpl to interpolate f
// and write the result to w
func (f Function) Execute(w io.Writer) error {
	if f.NoGenerateFn {
		return nil
	}

	err := fnTmpl.Execute(w, f)
	if err != nil {
		return errors.Wrapf(err, "failed to Execute with Function %+v", f)
	}

	return nil
}
